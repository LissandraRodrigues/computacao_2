head	1.2;
access;
symbols;
locks
	luiza.rosa:1.2; strict;
comment	@ * @;


1.2
date	2022.01.25.01.13.19;	author luiza.rosa;	state Exp;
branches;
next	1.1;

1.1
date	2022.01.24.18.48.15;	author luiza.rosa;	state Exp;
branches;
next	;


desc
@Programa: Arquivo de testes e tratamento de erros da funcao de complemento algebrico.
@


1.2
log
@Programa: Insercao de tratamento de erro para o valor maximo dos elementos.
@
text
@/*
 * Universidade Federal do Rio de Janeiro
 * Escola Politecnica
 * Departamento de Eletronica e de Computacao
 * EEL270 - Computacao II - Turma 2021/2
 * Professor: Marcelo Luiz Drumond Lanza
 *
 * Autor: Luiza Lissandra Rodrigues Rosa
 * Descricao: Programa de testes da funcao de
 *            calcular complemento algebrico.
 *
 * $Author: luiza.rosa $
 * $Date: 2022/01/24 18:48:15 $
 * $Log: aula0606.c,v $
 * Revision 1.1  2022/01/24 18:48:15  luiza.rosa
 * Initial revision
 *
*/

#ifdef __linux__
#define _XOPEN_SOURCE 600
#endif

#if defined (__FreeBSD__) && defined (__STRICT_ANSI__)
#define __ISO_C_VISIBLE 1999
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <float.h>

#include "aula0601.h"

#define SUCESSO																		0

#define NUMERO_ARGUMENTOS_INVALIDO								1
#define ARGUMENTO_INVALIDO												2
#define ARGUMENTO_CONTEM_CARACTERE_INVALIDO				3
#define MATRIZ_MEDIDAS_INVALIDAS		   						4
#define VALOR_MAXIMO_DOUBLE_EXCEDIDO							5

#define NUMERO_MINIMO_ARGUMENTOS									5  
#define EOS																				'\0'

int
main (int argc, char **argv) 
{

	char *verificacao;	

	double elemento;

	unsigned ordemMatriz,
					 medida,
					 quantidadeTotalElementos,
					 contador,
					 linha,
					 coluna,
	 				 linhaElemento,
					 colunaElemento;

	double matriz [QUANTIDADE_MATRIZ_LINHAS][QUANTIDADE_MATRIZ_COLUNAS],
				 cofator [0]; 

	if (argc < NUMERO_MINIMO_ARGUMENTOS)
	{
		printf ("\nUso: %s <ordem-da-matriz> <posicao-linha> <posicao-coluna> <a11> <a12> ... \n\n", argv [0]);
		exit (NUMERO_ARGUMENTOS_INVALIDO);
	}

	/* Ordem da matriz */

	if ((argv [1][0] == '-') || (argv [1][0] == '0'))
	{
		printf ("\nA ordem da matriz nao pode ser negativa ou nula.\n\n");
		exit (ARGUMENTO_INVALIDO);
	}

	medida = strtoul (argv [1], &verificacao, 10);

	if (*verificacao != EOS)
	{
		printf ("\nArgumento contem caractere invalido.\n");
		printf ("Primeiro caractere invalido: \'%c\'.\n\n", *verificacao);
		exit (ARGUMENTO_CONTEM_CARACTERE_INVALIDO);
	}

	ordemMatriz = medida;

	quantidadeTotalElementos = (ordemMatriz * ordemMatriz);
	
	if (quantidadeTotalElementos != (argc - 4))
	{
		printf ("\nQuantidade de elementos incorreta.\n");
		printf ("Sao esperados (%i) elementos de acordo com as medidas da matriz digitada.\n",
					  quantidadeTotalElementos);
		printf ("\nE tambem sao esperados 2 valores correspondentes a localizacao do elemento na matriz.\n\n");	
		exit (NUMERO_ARGUMENTOS_INVALIDO);
	}

  /* Localizacao do elemento */
		
	for (contador = 0; contador < 2; contador++)
	{
				
		if ((argv [contador +  2][0] == '-') || (argv [contador + 2][0] == '0')) 
		{
			printf ("\nOs valores da localizacao do elemento nao podem ser negativos ou nulos.\n\n");
			exit (ARGUMENTO_INVALIDO);
		}
	
		elemento = strtod (argv [contador + 2], &verificacao);

		if (*verificacao != EOS)
		{
			printf ("\nArgumento contem caractere invalido.\n");
			printf ("Primeiro caractere invalido: \'%c\'.\n\n", *verificacao);
			exit (ARGUMENTO_CONTEM_CARACTERE_INVALIDO);
		}

		if (!contador)
			linhaElemento = elemento;
		else
			colunaElemento = elemento;

	}

	/* Elementos */

	for (contador = 0; contador < quantidadeTotalElementos; contador++)
	{
		
		strtod (argv [contador + 4], &verificacao);

		if (*verificacao != EOS)
		{
			printf ("\nArgumento contem caractere invalido.\n");
			printf ("Primeiro caractere invalido: \'%c\'.\n\n", *verificacao);
			exit (ARGUMENTO_CONTEM_CARACTERE_INVALIDO);
		}

		if (errno == ERANGE)
		{
			printf ("\nO valor de um ou mais elementos ultrapassam o maximo permitido para double (%f).\n\n",
						  DBL_MAX);
			exit (VALOR_MAXIMO_DOUBLE_EXCEDIDO);
		}

	}

	contador = 4;

	for (linha = 0; linha < ordemMatriz; linha++)
		for (coluna = 0; coluna < ordemMatriz; coluna++) 
		{

			elemento = strtod (argv [contador], &verificacao);		

			matriz [linha][coluna] = elemento;
		
			contador++; 
	
		}

	/* Resultado */
	
	printf ("\nMatriz:\n");

	for (linha = 0; linha < ordemMatriz; linha++)
	{

		printf ("\n| ");

		for (coluna = 0; coluna < ordemMatriz; coluna++)
			printf ("%.05f | ", matriz [linha][coluna]);	

	}

	printf ("\n\nElemento [%d][%d]: %.05f\n", linhaElemento, colunaElemento, matriz [linhaElemento - 1][colunaElemento - 1]);
 
	CalcularComplementoAlgebrico (ordemMatriz, linhaElemento, colunaElemento, matriz, cofator);

	printf ("\nCofator = %.05f\n\n", cofator [0]);

	return SUCESSO;

}

/* $RCSfile: aula0606.c,v $ */
@


1.1
log
@Initial revision
@
text
@d12 6
a17 3
 * $Author$
 * $Date$
 * $Log$
d31 2
d39 4
a42 4
#define QUANTIDADE_CARACTERES_INVALIDA						2
#define ARGUMENTO_INVALIDO												3
#define ARGUMENTO_CONTEM_CARACTERE_INVALIDO				4
#define MATRIZ_MEDIDAS_INVALIDAS		   						5
d144 7
d181 1
a181 1
	printf ("\n\nElemento [%d][%d]: %1f\n", linhaElemento, colunaElemento, matriz [linhaElemento - 1][colunaElemento - 1]);
d185 1
a185 1
	printf ("\nCofator = %1f\n\n", cofator [0]);
d191 1
a191 1
/* $RCSfile$ */
@
